import { useState, useEffect, useCallback, useRef } from 'react';
import './App.css';
import Navigation from './components/Navigation';
import HomeScreen from './components/HomeScreen';
import ShopScreen from './components/ShopScreen';
import StatsScreen from './components/StatsScreen';
import NameInput from './components/NameInput';
import PetSelector from './components/PetSelector';
import Minigames from './components/Minigames';
import SkateGame from './components/SkateGame';
import EggScreen from './components/EggScreen';

function App() {
  // ==================== ESTADOS ====================
  const [currentScreen, setCurrentScreen] = useState('home');
  const [showNameInput, setShowNameInput] = useState(true);
  const [showPetSelector, setShowPetSelector] = useState(false);
  const [showMinigames, setShowMinigames] = useState(false);
  const [showSkateGame, setShowSkateGame] = useState(false);
  const [message, setMessage] = useState('');
  const [animation, setAnimation] = useState('');
  const [isSleeping, setIsSleeping] = useState(false);

  // Ref para almacenar el timeout del sue침o
  const sleepTimeoutRef = useRef(null);
  const sleepIntervalRef = useRef(null);
  const sleepStartEnergyRef = useRef(0);
  const sleepStartTimeRef = useRef(0);

  // Estado inicial de la mascota
  const initialPetState = {
    name: '',
    type: 'cat',
    color: 'white', // brown, white, black
    // Estad칤sticas principales
    hunger: 100,
    happiness: 100,
    energy: 100,
    cleanliness: 100,
    health: 100,
    // Progresi칩n
    stage: 'egg', // egg, baby, teen, adult
    level: 1,
    exp: 0,
    // Estado
    isAlive: true,
    isSick: false,
    mood: 'contento',
    dangerLevel: 'normal', // normal, alerta, critico, agonizante
    // Recursos
    coins: 50,
    age: 0,
    // Timestamps
    lastFed: Date.now(),
    lastPlayed: Date.now(),
    lastCleaned: Date.now(),
    birthDate: Date.now(),
    lastUpdate: Date.now(), // Timestamp de la 칰ltima actualizaci칩n
    criticalHungerStart: null, // Cuando el hambre lleg칩 a 0
    criticalHealthStart: null, // Cuando la salud lleg칩 a 0
    // Estado de sue침o
    isSleeping: false,
    sleepStartTime: null,
    sleepStartEnergy: null
  };

  const [pet, setPet] = useState(initialPetState);
  const [inventory, setInventory] = useState({
    food: 5,
    medicine: 2,
    treats: 1,
    soap: 3
  });

  // ==================== CARGAR/GUARDAR DATOS ====================
  useEffect(() => {
    const savedPet = localStorage.getItem('tamagotchiPet');
    const savedInventory = localStorage.getItem('tamagotchiInventory');

    if (savedPet) {
      const loadedPet = JSON.parse(savedPet);

      // Calcular tiempo transcurrido desde la 칰ltima actualizaci칩n
      const timeElapsed = Date.now() - (loadedPet.lastUpdate || Date.now());
      const minutesElapsed = timeElapsed / (1000 * 60); // Minutos transcurridos

      // Calcular edad inmediatamente al cargar
      loadedPet.age = Math.floor((Date.now() - loadedPet.birthDate) / (1000 * 60 * 60));

      // Aplicar deterioro offline SOLO si NO est치 durmiendo y NO est치 en etapa egg
      if (!loadedPet.isSleeping && loadedPet.stage !== 'egg' && loadedPet.isAlive) {
        // Deterioro por minuto (basado en el intervalo de 30 segundos)
        const decayRate = minutesElapsed / 0.5; // Cu치ntos intervalos de 30 segundos pasaron

        loadedPet.hunger = Math.max(0, loadedPet.hunger - (2 * decayRate));
        loadedPet.happiness = Math.max(0, loadedPet.happiness - (1.5 * decayRate));
        loadedPet.energy = Math.max(0, loadedPet.energy - (1 * decayRate));
        loadedPet.cleanliness = Math.max(0, loadedPet.cleanliness - (0.8 * decayRate));

        // Aplicar nuevo sistema de salud
        if (loadedPet.cleanliness < 20) {
          const healthDecay = loadedPet.hunger < 30 ? (3 * decayRate) : (1.5 * decayRate);
          loadedPet.health = Math.max(0, loadedPet.health - healthDecay);
        } else if (loadedPet.cleanliness > 50 && loadedPet.health < 100) {
          loadedPet.health = Math.min(100, loadedPet.health + (0.5 * decayRate));
        }

        // Aplicar deterioro de salud por hambre = 0
        if (loadedPet.hunger === 0) {
          loadedPet.health = Math.max(0, loadedPet.health - (2 * decayRate));
          if (!loadedPet.criticalHungerStart) {
            loadedPet.criticalHungerStart = loadedPet.lastUpdate || Date.now();
          }
        } else {
          loadedPet.criticalHungerStart = null;
        }

        if (loadedPet.health === 0 && !loadedPet.criticalHealthStart) {
          loadedPet.criticalHealthStart = loadedPet.lastUpdate || Date.now();
        } else if (loadedPet.health > 0) {
          loadedPet.criticalHealthStart = null;
        }

        // Verificar condiciones de muerte
        const now = Date.now();

        // Muerte por hambre prolongada (2 horas)
        if (loadedPet.criticalHungerStart && (now - loadedPet.criticalHungerStart) >= 7200000) {
          loadedPet.isAlive = false;
        }

        // Muerte por salud = 0 prolongada (30 minutos)
        if (loadedPet.criticalHealthStart && (now - loadedPet.criticalHealthStart) >= 1800000) {
          loadedPet.isAlive = false;
        }

        // Muerte por combo cr칤tico
        if (loadedPet.hunger < 10 && loadedPet.health < 10) {
          if (loadedPet.criticalComboStart && (now - loadedPet.criticalComboStart) >= 1800000) {
            loadedPet.isAlive = false;
          } else if (!loadedPet.criticalComboStart) {
            loadedPet.criticalComboStart = loadedPet.lastUpdate || Date.now();
          }
        }

        // Determinar nivel de peligro
        let dangerLevel = 'normal';
        if (loadedPet.hunger === 0 || loadedPet.health === 0) {
          dangerLevel = 'agonizante';
        } else if (loadedPet.hunger < 10 || loadedPet.health < 10) {
          dangerLevel = 'critico';
        } else if (loadedPet.hunger < 30 || loadedPet.health < 30) {
          dangerLevel = 'alerta';
        }

        // Determinar mood
        let mood = 'contento';
        let isSick = false;

        if (dangerLevel === 'agonizante') {
          mood = 'agonizando';
          isSick = true;
        } else if (dangerLevel === 'critico') {
          mood = 'enfermo';
          isSick = true;
        } else if (loadedPet.health < 30 || loadedPet.cleanliness < 20) {
          mood = 'enfermo';
          isSick = true;
        } else if (loadedPet.happiness > 80 && loadedPet.energy > 70 && loadedPet.hunger > 70) {
          mood = 'juguet칩n';
        } else {
          const stats = [
            { value: loadedPet.hunger, mood: 'hambriento', threshold: 30 },
            { value: loadedPet.energy, mood: 'cansado', threshold: 30 },
            { value: loadedPet.happiness, mood: 'triste', threshold: 40 }
          ];

          const lowStats = stats.filter(stat => stat.value < stat.threshold);
          if (lowStats.length > 0) {
            const lowestStat = lowStats.reduce((prev, current) =>
              current.value < prev.value ? current : prev
            );
            mood = lowestStat.mood;
          }
        }

        loadedPet.mood = mood;
        loadedPet.isSick = isSick;
        loadedPet.dangerLevel = dangerLevel;
      }

      // Actualizar timestamp
      loadedPet.lastUpdate = Date.now();

      // Restaurar estado de sue침o si estaba durmiendo
      if (loadedPet.isSleeping && loadedPet.sleepStartTime && loadedPet.sleepStartEnergy !== null) {
        setIsSleeping(true);
        setAnimation('blink');
        sleepStartTimeRef.current = loadedPet.sleepStartTime;
        sleepStartEnergyRef.current = loadedPet.sleepStartEnergy;

        // Calcular energ칤a actual basada en el tiempo transcurrido
        const totalSleepTime = 300000; // 5 minutos
        const timeSlept = Date.now() - loadedPet.sleepStartTime;
        const sleepProgress = Math.min(timeSlept / totalSleepTime, 1);
        const energyToRecover = 100 - loadedPet.sleepStartEnergy;
        const currentEnergy = Math.min(100, loadedPet.sleepStartEnergy + (energyToRecover * sleepProgress));

        loadedPet.energy = currentEnergy;

        // Si a칰n no ha completado los 5 minutos, continuar el intervalo
        if (timeSlept < totalSleepTime) {
          const updateInterval = 1000;
          sleepIntervalRef.current = setInterval(() => {
            setPet(prev => {
              const timeSlept = Date.now() - sleepStartTimeRef.current;
              const sleepProgress = Math.min(timeSlept / totalSleepTime, 1);
              const energyToRecover = 100 - sleepStartEnergyRef.current;
              const newEnergy = Math.min(100, sleepStartEnergyRef.current + (energyToRecover * sleepProgress));

              return {
                ...prev,
                energy: newEnergy
              };
            });
          }, updateInterval);

          // Timeout para detener el intervalo cuando complete los 5 minutos
          const remainingTime = totalSleepTime - timeSlept;
          sleepTimeoutRef.current = setTimeout(() => {
            if (sleepIntervalRef.current) {
              clearInterval(sleepIntervalRef.current);
              sleepIntervalRef.current = null;
            }

            setPet(prev => ({
              ...prev,
              energy: 100,
              happiness: Math.min(100, prev.happiness + 10)
            }));

            sleepTimeoutRef.current = null;
          }, remainingTime);
        } else {
          // Ya complet칩 los 5 minutos, energ칤a al 100%
          loadedPet.energy = 100;
        }
      }

      setPet(loadedPet);
      setShowNameInput(false);
    }
    if (savedInventory) {
      setInventory(JSON.parse(savedInventory));
    }
  }, []);

  useEffect(() => {
    if (!showNameInput && !showPetSelector && pet.name) {
      localStorage.setItem('tamagotchiPet', JSON.stringify(pet));
      localStorage.setItem('tamagotchiInventory', JSON.stringify(inventory));
    }
  }, [pet, inventory, showNameInput, showPetSelector]);

  // ==================== SISTEMA DE EVOLUCI칍N ====================
  useEffect(() => {
    // Solo evoluciona si ya naci칩 (no est치 en etapa egg)
    if (pet.stage === 'egg') return;

    if (pet.level >= 5 && pet.stage === 'baby') {
      setPet(prev => ({ ...prev, stage: 'teen' }));
      showMessage('Tu mascota ha crecido a adolescente');
    } else if (pet.level >= 10 && pet.stage === 'teen') {
      setPet(prev => ({ ...prev, stage: 'adult' }));
      showMessage('Tu mascota es ahora adulta');
    }
  }, [pet.level, pet.stage]);

  // Sistema de nivel basado en experiencia
  useEffect(() => {
    const expNeeded = pet.level * 100;
    if (pet.exp >= expNeeded) {
      setPet(prev => ({
        ...prev,
        level: prev.level + 1,
        exp: prev.exp - expNeeded,
        coins: prev.coins + 10
      }));

      showMessage(`Nivel ${pet.level + 1}! +10 monedas`);
    }
  }, [pet.exp, pet.level, showMessage]);

  // ==================== SISTEMA DE DETERIORO ====================
  useEffect(() => {
    // No deteriorar si est치 en etapa de huevo, en selecci칩n, o muerto
    if (showNameInput || showPetSelector || !pet.isAlive || pet.stage === 'egg') return;

    const decayInterval = setInterval(() => {
      setPet(prev => {
        // No deteriorar si est치 durmiendo
        if (prev.isSleeping) {
          return { ...prev, lastUpdate: Date.now() };
        }

        // Deterioro de estad칤sticas b치sicas
        const newHunger = Math.max(0, prev.hunger - 2);
        const newHappiness = Math.max(0, prev.happiness - 1.5);
        const newEnergy = Math.max(0, prev.energy - 1);
        const newCleanliness = Math.max(0, prev.cleanliness - 0.8);

        // ===== NUEVO SISTEMA DE SALUD =====
        let newHealth = prev.health;
        let newCriticalHealthStart = prev.criticalHealthStart;

        // La salud baja SOLO cuando est치 enfermo (limpieza < 20)
        if (newCleanliness < 20) {
          // Baja m치s r치pido si tambi칠n tiene hambre baja
          const healthDecay = newHunger < 30 ? 3 : 1.5;
          newHealth = Math.max(0, newHealth - healthDecay);
        } else if (newCleanliness > 50 && prev.health < 100) {
          // Recupera salud lentamente si est치 limpio
          newHealth = Math.min(100, newHealth + 0.5);
        }

        // ===== SISTEMA DE MUERTE POR HAMBRE =====
        let newCriticalHungerStart = prev.criticalHungerStart;

        if (newHunger === 0) {
          // Marcar cuando el hambre lleg칩 a 0
          if (!newCriticalHungerStart) {
            newCriticalHungerStart = Date.now();
          }
          // Bajar salud m치s r치pido cuando no come
          newHealth = Math.max(0, newHealth - 2);
        } else {
          // Resetear si vuelve a comer
          newCriticalHungerStart = null;
        }

        if (newHealth === 0 && !newCriticalHealthStart) {
          newCriticalHealthStart = Date.now();
        } else if (newHealth > 0) {
          newCriticalHealthStart = null;
        }

        // ===== VERIFICAR CONDICIONES DE MUERTE =====
        let isAlive = true;
        const now = Date.now();

        // Muerte por hambre prolongada (2 horas = 7200000 ms)
        if (newCriticalHungerStart && (now - newCriticalHungerStart) >= 7200000) {
          isAlive = false;
        }

        // Muerte por salud = 0 prolongada (30 minutos = 1800000 ms)
        if (newCriticalHealthStart && (now - newCriticalHealthStart) >= 1800000) {
          isAlive = false;
        }

        // Muerte inmediata si hambre < 10 Y salud < 10 por 30 minutos
        if (newHunger < 10 && newHealth < 10) {
          if (!prev.criticalComboStart) {
            // Primera vez en estado cr칤tico combo
            return {
              ...prev,
              hunger: newHunger,
              health: newHealth,
              criticalComboStart: Date.now(),
              lastUpdate: Date.now()
            };
          } else if ((now - prev.criticalComboStart) >= 1800000) {
            isAlive = false;
          }
        }

        // ===== DETERMINAR NIVEL DE PELIGRO =====
        let dangerLevel = 'normal';

        if (newHunger === 0 || newHealth === 0) {
          dangerLevel = 'agonizante';
        } else if (newHunger < 10 || newHealth < 10) {
          dangerLevel = 'critico';
        } else if (newHunger < 30 || newHealth < 30) {
          dangerLevel = 'alerta';
        }

        // ===== DETERMINAR MOOD =====
        let mood = 'contento';
        let isSick = false;

        if (dangerLevel === 'agonizante') {
          mood = 'agonizando';
          isSick = true;
        } else if (dangerLevel === 'critico') {
          mood = 'enfermo';
          isSick = true;
        } else if (newHealth < 30 || newCleanliness < 20) {
          mood = 'enfermo';
          isSick = true;
        } else if (newHappiness > 80 && newEnergy > 70 && newHunger > 70) {
          mood = 'juguet칩n';
        } else {
          const stats = [
            { value: newHunger, mood: 'hambriento', threshold: 30 },
            { value: newEnergy, mood: 'cansado', threshold: 30 },
            { value: newHappiness, mood: 'triste', threshold: 40 }
          ];

          const lowStats = stats.filter(stat => stat.value < stat.threshold);
          if (lowStats.length > 0) {
            const lowestStat = lowStats.reduce((prev, current) =>
              current.value < prev.value ? current : prev
            );
            mood = lowestStat.mood;
          }
        }

        return {
          ...prev,
          hunger: newHunger,
          happiness: newHappiness,
          energy: newEnergy,
          cleanliness: newCleanliness,
          health: newHealth,
          isSick,
          mood,
          isAlive,
          dangerLevel,
          criticalHungerStart: newCriticalHungerStart,
          criticalHealthStart: newCriticalHealthStart,
          lastUpdate: Date.now()
        };
      });
    }, 30000); // Cada 30 segundos

    return () => clearInterval(decayInterval);
  }, [showNameInput, showPetSelector, pet.isAlive]);

  // ==================== SISTEMA DE EDAD ====================
  useEffect(() => {
    if (showNameInput || showPetSelector || !pet.isAlive) return;

    const ageInterval = setInterval(() => {
      setPet(prev => ({
        ...prev,
        age: Math.floor((Date.now() - prev.birthDate) / (1000 * 60 * 60)) // 1 hora real = 1 d칤a
      }));
    }, 60000); // Cada minuto

    return () => clearInterval(ageInterval);
  }, [showNameInput, showPetSelector, pet.isAlive]);

  // ==================== FUNCIONES DE UTILIDAD ====================
  const showMessage = useCallback((msg) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), 8000);
  }, []);

  const getStatColor = useCallback((value) => {
    if (value > 70) return '#4ecca3';
    if (value > 40) return '#ffd93d';
    return '#ff6b6b';
  }, []);

  const getPetState = useCallback(() => {
    if (!pet.isAlive) return 'dead';
    if (pet.mood === 'enfermo') return 'sick';
    if (pet.mood === 'cansado') return 'tired';
    if (pet.mood === 'triste') return 'sad';
    return 'happy';
  }, [pet.isAlive, pet.mood]);

  // Funci칩n para despertar a la mascota
  const clearSleepState = useCallback(() => {
    if (sleepTimeoutRef.current) {
      clearTimeout(sleepTimeoutRef.current);
      sleepTimeoutRef.current = null;
    }
    if (sleepIntervalRef.current) {
      clearInterval(sleepIntervalRef.current);
      sleepIntervalRef.current = null;
    }
    if (isSleeping) {
      setIsSleeping(false);
      setAnimation('');
      // Limpiar el estado de sue침o del pet
      setPet(prev => ({
        ...prev,
        isSleeping: false,
        sleepStartTime: null,
        sleepStartEnergy: null
      }));
    }
  }, [isSleeping]);

  // ==================== ACCIONES DE CUIDADO ====================
  const feed = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (inventory.food <= 0) return showMessage('Sin comida! Ve a la tienda');

    // Despertar a la mascota si est치 durmiendo
    clearSleepState();

    setInventory(prev => ({ ...prev, food: prev.food - 1 }));
    setPet(prev => ({
      ...prev,
      hunger: Math.min(100, prev.hunger + 35),
      happiness: Math.min(100, prev.happiness + 10),
      exp: prev.exp + 10,
      lastFed: Date.now()
    }));

    setAnimation('jump');
    showMessage('Nam nam!');
    setTimeout(() => setAnimation(''), 8000);
  }, [pet.isAlive, inventory.food, showMessage, clearSleepState]);

  const sleep = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (isSleeping) return showMessage('Tu mascota ya est치 durmiendo');

    // Guardar energ칤a inicial y tiempo de inicio
    const sleepStart = Date.now();
    sleepStartEnergyRef.current = pet.energy;
    sleepStartTimeRef.current = sleepStart;

    // Establecer estado de sue침o
    setIsSleeping(true);
    setAnimation('blink');

    // Actualizar el pet con la informaci칩n de sue침o
    setPet(prev => ({
      ...prev,
      isSleeping: true,
      sleepStartTime: sleepStart,
      sleepStartEnergy: prev.energy
    }));

    showMessage('Dulces sue침os... (5 min para recuperaci칩n completa)');

    // Limpiar intervalos/timeouts anteriores si existen
    if (sleepTimeoutRef.current) {
      clearTimeout(sleepTimeoutRef.current);
    }
    if (sleepIntervalRef.current) {
      clearInterval(sleepIntervalRef.current);
    }

    // Intervalo para recuperar energ칤a gradualmente
    // 5 minutos = 300 segundos, actualizamos cada segundo
    // Recuperamos (100 - energ칤a actual) / 300 por segundo
    const totalSleepTime = 300000; // 5 minutos en ms
    const updateInterval = 1000; // Actualizar cada segundo

    sleepIntervalRef.current = setInterval(() => {
      setPet(prev => {
        const timeSlept = Date.now() - sleepStartTimeRef.current;
        const sleepProgress = Math.min(timeSlept / totalSleepTime, 1); // 0 a 1
        const energyToRecover = 100 - sleepStartEnergyRef.current;
        const newEnergy = Math.min(100, sleepStartEnergyRef.current + (energyToRecover * sleepProgress));

        return {
          ...prev,
          energy: newEnergy
        };
      });
    }, updateInterval);

    // Timeout para detener el intervalo despu칠s de 5 minutos (pero sigue durmiendo)
    sleepTimeoutRef.current = setTimeout(() => {
      // Detener el intervalo una vez alcanzada la energ칤a m치xima
      if (sleepIntervalRef.current) {
        clearInterval(sleepIntervalRef.current);
        sleepIntervalRef.current = null;
      }

      // Asegurar que la energ칤a est칠 al 100% y dar bonificaci칩n de felicidad
      setPet(prev => ({
        ...prev,
        energy: 100,
        happiness: Math.min(100, prev.happiness + 10)
      }));

      showMessage('Tu mascota est치 completamente descansada (sigue durmiendo)');
      sleepTimeoutRef.current = null;

      // NO cambiar isSleeping ni animation - sigue durmiendo
    }, totalSleepTime);
  }, [pet.isAlive, pet.energy, isSleeping, showMessage]);

  const clean = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (inventory.soap <= 0) return showMessage('Sin jab칩n! Ve a la tienda');

    // Despertar a la mascota si est치 durmiendo
    clearSleepState();

    setInventory(prev => ({ ...prev, soap: prev.soap - 1 }));
    setPet(prev => ({
      ...prev,
      cleanliness: 100,
      happiness: Math.min(100, prev.happiness + 15),
      exp: prev.exp + 8,
      lastCleaned: Date.now()
    }));

    showMessage('춰Qu칠 limpio!');
  }, [pet.isAlive, inventory.soap, showMessage, clearSleepState]);

  const giveMedicine = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (pet.mood !== 'enfermo') return showMessage('La medicina solo se puede usar cuando est치 enfermo');
    if (inventory.medicine <= 0) return showMessage('Sin medicina! Ve a la tienda');

    // Despertar a la mascota si est치 durmiendo
    clearSleepState();

    setInventory(prev => ({ ...prev, medicine: prev.medicine - 1 }));
    setPet(prev => ({
      ...prev,
      health: Math.min(100, prev.health + 40),
      cleanliness: Math.min(100, prev.cleanliness + 30),
      exp: prev.exp + 20
    }));

    // Feedback visual

    showMessage('Medicina administrada');

  const giveTreat = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (inventory.treats <= 0) return showMessage('Sin golosinas! Ve a la tienda');

    // Despertar a la mascota si est치 durmiendo
    clearSleepState();

    setInventory(prev => ({ ...prev, treats: prev.treats - 1 }));
    setPet(prev => ({
      ...prev,
      happiness: Math.min(100, prev.happiness + 30),
      hunger: Math.min(100, prev.hunger + 10),
      exp: prev.exp + 15
    }));

    // Feedback visual

    showMessage('춰Qu칠 rico!');

  const play = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (pet.energy < 30) return showMessage('Tu mascota necesita m치s energ칤a (m칤n. 30)');

    // Despertar a la mascota si est치 durmiendo
    clearSleepState();

    setPet(prev => ({
      ...prev,
      energy: Math.max(0, prev.energy - 20),
      happiness: Math.min(100, prev.happiness + 15),
      exp: prev.exp + 5
    }));

    // Feedback visual

    setAnimation('jump');
    showMessage('A jugar!');
    setTimeout(() => setAnimation(''), 8000);
    setShowMinigames(true);

  // ==================== SISTEMA DE TIENDA ====================
  const buyItem = useCallback((item, price) => {
    if (pet.coins < price) return showMessage('No tienes suficientes monedas');

    setPet(prev => ({ ...prev, coins: prev.coins - price }));
    setInventory(prev => ({ ...prev, [item]: prev[item] + 1 }));
    showMessage(`Has comprado ${item}`);
  }, [pet.coins, showMessage]);

  // ==================== MANEJO DE INPUTS ====================
  const handleNameSubmit = useCallback((name) => {
    setPet(prev => ({ ...prev, name, birthDate: Date.now() }));
    setShowNameInput(false);
    setShowPetSelector(true);
  }, []);

  const handlePetSelect = useCallback((type, color) => {
    setPet(prev => ({ ...prev, type, color }));
    setShowPetSelector(false);
  }, []);

  // ==================== SISTEMA DE MINI-JUEGOS ====================
  const openMinigames = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (pet.energy < 30) return showMessage('Tu mascota necesita m치s energ칤a (m칤n. 30)');
    setShowMinigames(true);
  }, [pet.isAlive, pet.energy, showMessage]);

  const closeMinigames = useCallback(() => {
    setShowMinigames(false);
  }, []);

  const handleMinigameWin = useCallback((reward) => {
    setPet(prev => ({
      ...prev,
      coins: prev.coins + reward.coins,
      exp: prev.exp + reward.exp,
      happiness: Math.min(100, prev.happiness + reward.happiness),
      energy: Math.max(0, prev.energy - 20)
    }));

    // Feedback visual

    showMessage(`Victoria! +${reward.coins} monedas +${reward.exp} XP`);
    setShowMinigames(false);

  const handleMinigameLose = useCallback(() => {
    setPet(prev => ({
      ...prev,
      energy: Math.max(0, prev.energy - 15),
      happiness: Math.max(0, prev.happiness - 5)
    }));
    showMessage('Mejor suerte la proxima vez');
    setShowMinigames(false);
  }, [showMessage]);

  // ==================== JUEGO DE SKATE ====================
  const openSkateGame = useCallback(() => {
    if (!pet.isAlive) return showMessage('Tu mascota ha fallecido...');
    if (pet.energy < 20) return showMessage('Tu mascota necesita m치s energ칤a (m칤n. 20)');
    setShowSkateGame(true);
  }, [pet.isAlive, pet.energy, showMessage]);

  const handleSkateGameEnd = useCallback((score) => {
    // Recompensa basada en el score
    const coinsEarned = Math.floor(score / 10);
    const expEarned = Math.floor(score / 5);
    const happinessGained = Math.min(30, Math.floor(score / 15));

    setPet(prev => ({
      ...prev,
      coins: prev.coins + coinsEarned,
      exp: prev.exp + expEarned,
      happiness: Math.min(100, prev.happiness + happinessGained),
      energy: Math.max(0, prev.energy - 15)
    }));

    // Feedback visual
    if (score > 0) {
      showMessage(`Score: ${score}! +${coinsEarned} monedas +${expEarned} XP`);
    } else {
      showMessage('Int칠ntalo de nuevo!');
    }

    setShowSkateGame(false);

  // Handler para cuando el huevo eclosiona
  const handleHatch = useCallback(() => {
    setPet(prev => ({
      ...prev,
      stage: 'baby',
      birthDate: Date.now()
    }));
    showMessage(`춰${pet.name} ha nacido! Bienvenido al mundo!`);
  }, [pet.name, showMessage]);

  // ==================== RENDERIZADO CONDICIONAL ====================
  if (showNameInput) {
    return <NameInput onSubmit={handleNameSubmit} />;
  }

  if (showPetSelector) {
    return <PetSelector petName={pet.name} onSelect={handlePetSelect} />;
  }

  // Mostrar pantalla de huevo si est치 en etapa egg
  if (pet.stage === 'egg') {
    return <EggScreen pet={pet} onHatch={handleHatch} />;
  }

  // ==================== RENDERIZADO DE PANTALLAS ====================
  const renderScreen = () => {
    const commonProps = {
      pet,
      inventory,
      message,
      animation
    };

    switch (currentScreen) {
      case 'home':
        return (
          <HomeScreen
            {...commonProps}
            getPetState={getPetState}
            getStatColor={getStatColor}
            onFeed={feed}
            onSleep={sleep}
            onWakeUp={clearSleepState}
            onClean={clean}
            onMedicine={giveMedicine}
            onTreat={giveTreat}
            onPlay={play}
            isSleeping={isSleeping}
          />
        );

      case 'shop':
        return <ShopScreen {...commonProps} onBuyItem={buyItem} />;

      case 'stats':
        return (
          <div className="stats-wrapper" style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '20px'
          }}>
            <StatsScreen pet={pet} inventory={inventory} />

            <button
              className="reset-button"
              style={{
                background: '#f44336',
                color: 'white',
                padding: '15px 30px',
                border: '4px solid black',
                fontFamily: '"Press Start 2P"',
                fontSize: '10px',
                cursor: 'pointer',
                marginTop: '10px'
              }}
              onClick={() => {
                if (window.confirm('쮼st치s seguro de que quieres reiniciar?')) {
                  localStorage.clear();
                  window.location.reload();
                }
              }}
            >
              REINICIAR 游댃
            </button>
          </div>
        );

      default:
        return <HomeScreen {...commonProps} getPetState={getPetState} />;
    }
  };

  // ==================== RENDER PRINCIPAL ====================
  return (
    <div className="app-container">
      {renderScreen()}
      <Navigation currentScreen={currentScreen} onNavigate={setCurrentScreen} />

      {showMinigames && (
        <Minigames
          petName={pet.name}
          petType={pet.type}
          coins={pet.coins}
          onClose={closeMinigames}
          onWin={handleMinigameWin}
          onLose={handleMinigameLose}
          onOpenSkateGame={openSkateGame}
        />
      )}

      {showSkateGame && (
        <SkateGame
          onGameEnd={handleSkateGameEnd}
        />
      )}

      {/* Feedback visual: N칰meros flotantes */}
      {floatingNumbers.map((num, index) => (
        <FloatingNumber
          key={num.id}
          value={num.value}
          type={num.type}
          index={index}
          onComplete={() => removeFloatingNumber(num.id)}
        />
      ))}

      {/* Feedback visual: Part칤culas */}
      {particles.map(p => (
        <Particles
          key={p.id}
          type={p.type}
          count={p.count}
          onComplete={() => removeParticles(p.id)}
        />
      ))}
    </div>
  );
}

export default App;
